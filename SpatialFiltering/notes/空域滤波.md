# 图像算法基础——空间滤波

“滤波”一次其实是借鉴于频域处理，在频域滤波是指接受或者拒绝一定频率的分量，比如常见的低通滤波器就是让低频率的分量通过而阻止高频率分量。相反高通滤波器则是让高频率分量通过而阻止低频率的分量通过。而在空间域我们利用空间滤波器（核、窗口或者别的叫法）通过一定的运算直接作用在图像本身上达到类类似的效果，所以我们也把在空间域通过滤波器的运算这种操作叫做空间滤波。

在正式开始正文之前，我觉得还是先来讨论讨论低频高频的物理意义。

![](D:\ISP\DigitalImageProcessing\SpatialFiltering\images\1.jpg)

如图所示，红色、绿色、蓝色分别代表这频率不断增强的波形。在上图我们都能看出对于低频信号，变化程度明显比高频的弱，最低频的就是红色波形，我们称之为直流分量，一点变化都没有。所以以此类推在图像中，高频分量对应变化剧烈的部分，而低频分量对应没有什么变化的区域。而对于图像而言，变化剧烈的很明显就是边缘和细节，而不怎变化的区域对应着平坦区域，所以**频率对于图像的物理意义就是，高频对应变化剧烈的边缘或者细节，而低频则对应变化小的平坦区域**。进一步我们也很容易就能联想到低频滤波就是把高频滤除掉，那么高频分量减少就会使得图像边缘和细节不明显从而变模糊，但是噪点是正常图像中一个突然不同的部分，所以早掉的变化也是很大的同样属于高频分量，所以低通滤波有去噪的功能。同理，高通滤波则是反过来，刚好是提取边缘。



---

## 平滑空间滤波

从上面的讨论我们就能知道平滑空间滤波可以用于模糊处理和降低噪声，所以下面将直接介绍几种常见的平滑滤波器。

### 均值滤波

均值滤波很简单，就是在一个像素周围定义一个邻域，求出这个邻域所有像素的平均值然后赋值给该像素。平均操作$$ \frac{a+b}{2}$$就是将两个是往中间折中，所以很明显能够降低变化的程度从而达到平滑的效果。



#### 算法说明

我们定义一个3*3的邻域，然后在邻域中求取平均值就能实现均值滤波。

用数学公式表示就是$$f(i, j) = \frac{1}{9} * [f(i-1, j-1)+f(i-1, j)+f(i-1, j+1)+f(i, j-1)+f(i, j)+f(i, j+1)+f(i+1, j-1)+f(i+1, j)+f(i+1, j+1))]$$

然后遍历整个图像就可以完成均值滤波。

我们知道还有一种叫做加权平均值，就是平均之前每每个数的权重不一样，其实在图形中更好理解，某一个点的值肯定和本身的像素值关系最大，所以对应的本身哪个点的权重就会更大些，我么通过以下公式计算
$$
\begin{aligned} 
f(i, j) = \frac{1}{16} * [&f(i-1, j-1) *1 +f(i-1, j) * 2+f(i-1, j+1)*1+\\
           & f(i, j-1)*2+f(i, j)*4+f(i, j+1)*2+f(i+1, j-1)*1+f(i+1, j)*2+f(i+1, j+1)*1)]
\end{aligned}
$$


我们把邻域中每个像素的权重提取出来就有



![image-20210306134022719](D:\ISP\DigitalImageProcessing\SpatialFiltering\images\2.png)![image-20210306134128667](D:\ISP\DigitalImageProcessing\SpatialFiltering\images\3.png)



这样的一个矩阵，我们就把这个称之为滤波器或者模板，然后让其在图像上滑动，处理完整个图像即可。

#### 算法实现

```matlab
%% --------------------------------
%% author:wtzhu
%% email:wtzhu_13@163.com
%% date: 20210306
%% fuction: 均值滤波
%% --------------------------------
clear;
clc;
close all;
img = imread('./images/test_pattern_blurring_orig.tif');
[m, n] = size(img);
figure;subplot(221);imshow(img);title('original image');

%% 运算的时候需要对边缘进行扩展
% 需要特殊处理四周最外圈的行和列，本算法中将其向外扩展一圈，用最外圈的值填充
headRowMat = img(1,:);%取f的第1行
tailRowMat = img(m,:);%取f的第m行
% 行扩展后，列扩展时需要注意四个角需要单独扩展进去，不然就成了十字架形的
headColumnMat = [img(1,1), img(:,1)', img(m,1)];
tailColumnMat = [img(1,n), img(:,n)', img(m,n)];
expandImage = [headRowMat; img; tailRowMat];
expandImage = [headColumnMat; expandImage'; tailColumnMat];
expandImage = uint8(expandImage');
subplot(222);imshow(expandImage);title('expand image');

% 创建新的图像
newImg = zeros(m, n);
% 定义模板
meanKernal = uint8([1 1 1;
                    1 1 1
                    1 1 1]);
% 遍历图像进行均值滤波
% 1.首先提取图像中待操作的ROI
% 2.利用模板对提取的ROI进行运算并赋值给新的图像
for i =2: m+1
    for j =2: n+1
       imgRoi = [expandImage(i-1, j-1) expandImage(i-1, j) expandImage(i-1, j+1);
                 expandImage(i  , j-1) expandImage(i  , j) expandImage(i  , j+1);
                 expandImage(i+1, j-1) expandImage(i+1, j) expandImage(i+1, j+1)];
       newImg(i-1, j-1) = uint8(sum(sum(imgRoi.*meanKernal))/9);
    end
end
newImg = uint8(newImg);
subplot(223);imshow(newImg);title('new image');
subplot(224);imshow(img-newImg);title('newImg-img');
```

运行结果：![](D:\ISP\DigitalImageProcessing\SpatialFiltering\images\meanFilter.jpg)

如图所示，地方附图就是经过均值滤波处理后的效果，和第一幅图比起来变得更模糊。通过原始图像和新图像最差就能得到最后的图像，新清晰的看到边缘和部分噪点是被滤除掉了。通过更换不同的滤波器就能实现不同的均值滤波。

#### 总结

一般对于有均值滤波有一些特点：

- 模板尺寸越大，图像越模糊，图像细节丢失越多；
- 如果目的是去噪，那么在去噪的同时会平滑边和尖锐的细节；
- 某些情况下，对图像的低通滤波具有增强大尺度特性的作用。



### 中值滤波

其实中值滤波是一种非线性滤波，也是统计排序滤波器中的一种。统计滤波器的设计通过上面均值滤波器的讲解其实也很容易理解。就是定义一个邻域区间，然后对这个区间中的所有像素进行排序，然后在排序结果中取一个像素值作为新的像素值。最常见的就是取最大最小和中值，也被称为最大值滤波、最小值滤波和中值滤波。其中用的最多的就是中值滤波，具有很好的去噪效果，所以接下来主要介绍中值滤波。

#### 算法说明

1. 定义一个邻域区间，比如3*3，当然也可以定义为更大的，但是一般为奇数；
2. 对$$ [f(i-1, j-1),f(i-1, j),f(i-1, j+1),f(i, j-1),f(i, j),f(i, j+1),f(i+1, j-1),f(i+1, j),f(i+1, j+1)]$$数组进行排序得到一个新的有序数组orderedList；
3. 将排序后的结果的中位值赋值给新的像素$$new(i, j) = mid(orderedList)$$

#### 算法实现

```matlab
%% --------------------------------
%% author:wtzhu
%% email:wtzhu_13@163.com
%% date: 20210306
%% fuction: 中值滤波
%% --------------------------------
clear;
clc;
close all;
img = imread('./images/test_pattern_blurring_orig.tif');
[m, n] = size(img);
figure;subplot(221);imshow(img);title('original image');

%% 运算的时候需要对边缘进行扩展
% 需要特殊处理四周最外圈的行和列，本算法中将其向外扩展一圈，用最外圈的值填充
headRowMat = img(1,:);%取f的第1行
tailRowMat = img(m,:);%取f的第m行
% 行扩展后，列扩展时需要注意四个角需要单独扩展进去，不然就成了十字架形的
headColumnMat = [img(1,1), img(:,1)', img(m,1)];
tailColumnMat = [img(1,n), img(:,n)', img(m,n)];
expandImage = [headRowMat; img; tailRowMat];
expandImage = [headColumnMat; expandImage'; tailColumnMat];
expandImage = uint8(expandImage');
subplot(222);imshow(expandImage);title('expand image');

newImg = zeros(m, n);
for i =2: m+1
    for j =2: n+1
       imgRoi = [expandImage(i-1, j-1) expandImage(i-1, j) expandImage(i-1, j+1) ...
                 expandImage(i  , j-1) expandImage(i  , j) expandImage(i  , j+1) ...
                 expandImage(i+1, j-1) expandImage(i+1, j) expandImage(i+1, j+1)];
       orderedList = sort(imgRoi);
       sizeRoi = size(imgRoi);
       newImg(i-1, j-1) = orderedList((sizeRoi(2)+1)/2);
    end
end
newImg = uint8(newImg);
subplot(223);imshow(newImg);title('new image');
subplot(224);imshow(img-newImg);title('newImg-img');
```

运行结果：![](D:\ISP\DigitalImageProcessing\SpatialFiltering\images\midFilter.jpg)

#### 总结

通过看第三幅图像和第一幅图像的对比，可以很明显看到右侧矩形中的噪点处理的很好，而且边缘基本保留了。

所以中值滤波最大的特点就是在去除噪音的同时可以比较好地保留边缘轮廓和图像细节。



---

## 锐化空间滤波



